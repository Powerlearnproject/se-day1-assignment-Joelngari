[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18370218&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering.

Explain what software engineering is and discuss its importance in the technology industry.

it is a branch of computer science used for developing, testing and maintaining software.
reliability-software engineering ensures that software systems perform as expected.
security-softare engineering ensures security of users'information through encryption and authentication



Identify and describe at least three key milestones in the evolution of software engineering.

.Introduction of Structured Programming (1960s-70s)
Emphasized clear, logical structures (loops, conditionals) to improve code readability and reduce errors.
.Object-Oriented Programming (1980s)
Introduced concepts like classes and inheritance, promoting code reusability and modularity (e.g., C++, Java).
.Agile Methodology (2001)
Focused on iterative development, collaboration, and flexibility, replacing rigid models like Waterfall.


List and briefly explain the phases of the Software Development Life Cycle.

.planning - identify the software requirement or purpose and scope.
 requirement analysis - identify the user requirements
.design - here,the developers designs the software framework.
.implementation- converting software design into  code.
 .testing - examine the software for any bugs and glitches
 .maintenance-provides updates and continued support.

Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.

waterfall methodology - Linear and sequential, each phase is completed before moving on. 
- there is Low flexibility,
   user feedback comes after the product is developed.
 - Testing is done at the end of the development process.
 - Best for: Projects with clear, fixed requirements (e.g., government systems, construction software).


agile methodology - Iterative and incremental, with multiple cycles.
- High flexibility, adapts to changing requirements. 
- Regular user feedback is incorporated into every cycle. 
- Testing is continuous and done after each iteration.
- Best for: Dynamic projects with evolving requirements (e.g., mobile apps, startups).




Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.

software developer-developing applications,programs and systems using programming languages and frameworks.
 - maintaining and updating software to keep it functional. 
- collaborating with other team members to ensure best practice when developing software.
 - reporting to the project manager about the progress of the software development.
 - 
 - Quality Assurance Engineer - collaborate with stakeholders to understand and clarify software requirement.
 - create development standards and procedures for the programmers to follow
 - confirm that the software meets the requirement before deployment. 
- analyse the product to identify bugs and suggest changes to make them more efficient. 

Project Manager - assembles and lead the software development team.
 - discuss the project and it's requirement with the client and software developers.
 - create blueprint for the project.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.

Integrated Development Environments (IDEs)
Importance: Provide tools like code editors, debuggers, and compilers in one platform, boosting productivity and reducing errors.
Examples: Visual Studio Code, IntelliJ IDEA, PyCharm.

Version Control Systems (VCS)
Importance: Track changes, enable collaboration, and manage code history, making it easy to revert or merge changes.
Examples: Git, Subversion (SVN), Mercurial.


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.


Managing Complex Codebases
Strategy: Use modular design, follow coding standards, and maintain clear documentation.

Meeting Deadlines
Strategy: Use Agile methods, set realistic timelines, and break tasks into manageable sprints.
Debugging and Fixing Bugs
Strategy: Implement thorough testing (unit, integration), use debugging tools, and conduct code reviews.

Keeping Up with Technology Changes
Strategy: Continuous learning through courses, attending workshops, and following industry trends.

Effective Team Communication
Strategy: Use collaboration tools and hold regular team meetings.


Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.

Unit Testing It tests the individual components or functions of a specific module of the system.
Importance: Catches bugs early and ensures each part works as expected.

Integration Testing -It tests the interaction between multiple modules of the software
Importance: Ensures components work together smoothly.

System Testing- it tests the entire system as a whole.
Importance: Validates overall functionality, performance, and compliance with requirements.

Acceptance Testing-It tests the Software against user requirements.
Importance: Confirms the system meets user needs before release (e.g., UAT - User Acceptance Testing).


#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.

is the process where you guide generative AI solutions to generate desired outputs.




Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.

Vague Prompt:Improve the app.

Improved Prompt:Enhance the app's user interface by simplifying the navigation menu and reducing load times on the homepage.

Why It's More Effective:
Clear: Specifies which part of the app to improve (user interface).
Specific: Focuses on navigation and load times.
Concise: Directly outlines actionable tasks for developers.
